<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>8-Bit Buster Action v4</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            background-color: #202020;
            color: white;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Press Start 2P', monospace;
            touch-action: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            border: 4px solid #404040;
            background-color: #000;
            width: 512px;
            height: 448px;
            max-width: 100%;
            max-height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        /* UI Layer (Health Bars) */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .hud-container {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }

        .bar-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .bar-label {
            font-size: 16px;
            color: #fff;
            margin-bottom: 4px;
            text-shadow: 2px 2px 0 #000;
        }

        .health-bar {
            width: 24px;
            height: 120px;
            background: #000;
            border: 2px solid #fff;
            display: flex;
            flex-direction: column-reverse; /* Bottom to top fill */
            padding: 2px;
            box-sizing: border-box;
        }

        .hp-segment {
            width: 100%;
            height: 3.5%; /* Close to 28 segments */
            background-color: #fce883;
            margin-bottom: 1px;
        }
        
        .hp-boss .hp-segment { background-color: #ff4d4d; }
        
        /* Hidden initially */
        #boss-hud { visibility: hidden; }

        /* Mobile Controls */
        #mobile-controls {
            display: none;
            width: 100%;
            max-width: 512px;
            margin-top: 10px;
            justify-content: space-between;
            padding: 0 10px;
            box-sizing: border-box;
            align-items: center;
        }

        @media (pointer: coarse) {
            #mobile-controls { display: flex; }
        }

        .d-pad-grid {
            display: grid;
            grid-template-columns: 48px 48px 48px;
            grid-template-rows: 48px 48px 48px;
            gap: 2px;
        }

        .d-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            font-size: 20px;
        }
        .d-btn:active { background: rgba(255, 255, 255, 0.4); }
        
        #btn-up { grid-column: 2; grid-row: 1; border-radius: 8px 8px 0 0; }
        #btn-left { grid-column: 1; grid-row: 2; border-radius: 8px 0 0 8px; }
        #btn-right { grid-column: 3; grid-row: 2; border-radius: 0 8px 8px 0; }
        #btn-down { grid-column: 2; grid-row: 3; border-radius: 0 0 8px 8px; }

        .action-buttons {
            display: flex;
            gap: 12px;
            padding-right: 10px;
        }

        .btn-action {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            user-select: none;
            color: white;
        }
        .btn-action:active { background: rgba(255, 255, 255, 0.5); }
        .btn-b { background: rgba(255, 80, 80, 0.2); }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="512" height="448"></canvas>
        <div id="ui-layer">
            <div class="hud-container">
                <div class="bar-group">
                    <div class="bar-label">P</div>
                    <div class="health-bar hp-player" id="player-hp"></div>
                </div>
                <div class="bar-group" id="boss-hud">
                    <div class="bar-label">B</div>
                    <div class="health-bar hp-boss" id="boss-hp"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="mobile-controls">
        <div class="d-pad-grid">
            <div class="d-btn" id="btn-up">↑</div>
            <div class="d-btn" id="btn-left">←</div>
            <div class="d-btn" id="btn-right">→</div>
            <div class="d-btn" id="btn-down">↓</div>
        </div>
        <div class="action-buttons">
            <div class="btn-action btn-b" id="btn-shoot">B</div>
            <div class="btn-action" id="btn-jump">A</div>
        </div>
    </div>

<script>
/**
 * 8-Bit Action Game v4
 * Fixes: Bullet cleanup logic (infinite ammo fix)
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const playerHpEl = document.getElementById('player-hp');
const bossHudEl = document.getElementById('boss-hud');
const bossHpEl = document.getElementById('boss-hp');

// --- Constants ---
const TILE_SIZE = 32;
const GRAVITY = 0.5;
const TERMINAL_VELOCITY = 12;
const JUMP_FORCE = -9.5;
const SPEED = 3;
const SLIDE_SPEED = 6;
const BULLET_SPEED = 8;
const VIEWPORT_WIDTH = 512;
const VIEWPORT_HEIGHT = 448;
const MAX_HP = 28;

// Boss Room Logic
const BOSS_GATE_TILE_X = 64; // X index of the gate
const BOSS_ROOM_TILE_X = 65; // Where the boss room officially starts (camera lock)
const BOSS_ROOM_WIDTH_TILES = 16; // One screen width (512 / 32 = 16)

// --- Input System ---
const keys = { left: false, right: false, up: false, down: false, jump: false, shoot: false };
const inputState = { jumpPressed: false, shootPressed: false };
let inputEnabled = true;

const handleKey = (code, isDown) => {
    if(code === 'ArrowLeft') keys.left = isDown;
    if(code === 'ArrowRight') keys.right = isDown;
    if(code === 'ArrowUp') keys.up = isDown;
    if(code === 'ArrowDown') keys.down = isDown;
    if(code === 'KeyZ' || code === 'Space') {
        if(isDown && !keys.jump) inputState.jumpPressed = true;
        keys.jump = isDown;
    }
    if(code === 'KeyX' || code === 'KeyS') {
        if(isDown && !keys.shoot) inputState.shootPressed = true;
        keys.shoot = isDown;
    }
};

document.addEventListener('keydown', e => handleKey(e.code, true));
document.addEventListener('keyup', e => handleKey(e.code, false));

const bindTouch = (id, key) => {
    const el = document.getElementById(id);
    if(!el) return;
    el.addEventListener('touchstart', (e) => { e.preventDefault(); handleKeyByString(key, true); });
    el.addEventListener('touchend', (e) => { e.preventDefault(); handleKeyByString(key, false); });
};
const handleKeyByString = (key, isDown) => {
    keys[key] = isDown;
    if(key === 'jump' && isDown) inputState.jumpPressed = true;
    if(key === 'shoot' && isDown) inputState.shootPressed = true;
};
bindTouch('btn-left', 'left');
bindTouch('btn-right', 'right');
bindTouch('btn-up', 'up');
bindTouch('btn-down', 'down');
bindTouch('btn-jump', 'jump');
bindTouch('btn-shoot', 'shoot');

// --- Game State Globals ---
let cameraX = 0;
let cameraLock = { min: 0, max: 10000 };
let gameState = 'START';
let frameCount = 0;

// --- Entity Classes ---

class Entity {
    constructor(x, y, w, h, color) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.vx = 0;
        this.vy = 0;
        this.color = color;
        this.grounded = false;
        this.facingRight = true;
        this.hp = MAX_HP;
        this.dead = false;
        this.invincible = 0;
    }

    update() {
        if (this.dead) return;
        
        this.vy += GRAVITY;
        if (this.vy > TERMINAL_VELOCITY) this.vy = TERMINAL_VELOCITY;

        this.x += this.vx;
        this.checkCollisionX();
        this.y += this.vy;
        this.checkCollisionY();

        if (this.invincible > 0) this.invincible--;
    }

    draw() {
        if (this.dead) return;
        if (this.invincible > 0 && frameCount % 4 === 0) return;
        drawRect(this.x, this.y, this.w, this.h, this.color);
    }

    checkCollisionX() {
        for (let p of platforms) {
            if (p.active === false) continue;
            if (this.rectIntersect(this.x, this.y, this.w, this.h, p.x, p.y, p.w, p.h)) {
                if (this.vx > 0) this.x = p.x - this.w;
                else if (this.vx < 0) this.x = p.x + p.w;
                this.vx = 0;
            }
        }
    }

    checkCollisionY() {
        this.grounded = false;
        for (let p of platforms) {
            if (p.active === false) continue;
            if (this.rectIntersect(this.x, this.y, this.w, this.h, p.x, p.y, p.w, p.h)) {
                if (this.vy > 0) {
                    this.y = p.y - this.h;
                    this.grounded = true;
                    this.vy = 0;
                } else if (this.vy < 0) {
                    this.y = p.y + p.h;
                    this.vy = 0;
                }
            }
        }
    }

    rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
        return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
    }

    takeDamage(amount) {
        if (this.invincible > 0 || this.dead) return;
        this.hp -= amount;
        this.invincible = 60;
        if (this.hp <= 0) this.die();
    }

    die() {
        this.dead = true;
        createExplosion(this.x + this.w/2, this.y + this.h/2);
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 24, 24, '#00FFFF');
        this.color2 = '#0000FF';
        this.sliding = false;
        this.slideTimer = 0;
    }

    update() {
        if (this.dead) return;

        if (!inputEnabled) {
            this.vy += GRAVITY;
            this.x += this.vx;
            this.checkCollisionX();
            this.y += this.vy;
            this.checkCollisionY();
            return;
        }

        // Slide
        if (inputState.jumpPressed && keys.down && this.grounded && !this.sliding) {
            this.sliding = true;
            this.slideTimer = 25;
            this.h = 14; 
            this.y += 10; 
            inputState.jumpPressed = false;
            createDust(this.x, this.y + this.h);
        }
        else if (inputState.jumpPressed && this.grounded && !this.sliding) {
            this.vy = JUMP_FORCE;
            inputState.jumpPressed = false;
        }

        if (this.sliding) {
            this.vx = this.facingRight ? SLIDE_SPEED : -SLIDE_SPEED;
            this.slideTimer--;
            if (this.slideTimer <= 0) {
                let blocked = platforms.some(p => p.active !== false && this.rectIntersect(this.x, this.y - 10, this.w, 24, p.x, p.y, p.w, p.h));
                if (!blocked) {
                    this.sliding = false;
                    this.y -= 10;
                    this.h = 24;
                    this.vx = 0;
                } else {
                    this.slideTimer = 1;
                }
            }
            if (Math.abs(this.vx) < 1) this.slideTimer = 0; 
        } else {
            if (keys.left) { this.vx = -SPEED; this.facingRight = false; }
            else if (keys.right) { this.vx = SPEED; this.facingRight = true; }
            else { this.vx = 0; }
        }

        // Shoot Logic
        if (inputState.shootPressed) {
            // Check only active friendly bullets
            const count = bullets.filter(b => b.friendly && !b.dead).length;
            if (count < 3) {
                let bx = this.facingRight ? this.x + this.w : this.x - 8;
                let by = this.sliding ? this.y + 4 : this.y + 8;
                bullets.push(new Bullet(bx, by, this.facingRight, true));
            }
            inputState.shootPressed = false;
        }

        super.update();

        if (this.x < cameraLock.min) { this.x = cameraLock.min; this.vx = 0; }
        if (this.x + this.w > cameraLock.max) { this.x = cameraLock.max - this.w; this.vx = 0; }

        if (this.y > VIEWPORT_HEIGHT + 64) {
            this.hp = 0;
            this.die();
        }
    }

    draw() {
        if (this.dead) return;
        if (this.invincible > 0 && frameCount % 4 === 0) return;

        let cx = Math.floor(this.x - cameraX);
        let cy = Math.floor(this.y);

        if (this.sliding) {
            ctx.fillStyle = this.color2;
            ctx.fillRect(cx+2, cy+2, 20, 12);
            ctx.fillStyle = this.color;
            ctx.fillRect(cx+14, cy, 10, 8);
            ctx.fillStyle = '#ffccaa';
            ctx.fillRect(cx+18, cy+2, 4, 4);
        } else {
            ctx.fillStyle = this.color2;
            ctx.fillRect(cx+4, cy+8, 16, 12);
            ctx.fillStyle = this.color;
            ctx.fillRect(cx+6, cy, 12, 10);
            ctx.fillStyle = '#ffccaa';
            let fx = this.facingRight ? cx+10 : cx+8;
            ctx.fillRect(fx, cy+2, 6, 6);
            ctx.fillStyle = this.color;
            let step = (this.vx !== 0 && frameCount % 12 < 6) ? 0 : 1;
            if(step) {
                ctx.fillRect(cx+4, cy+20, 6, 4); ctx.fillRect(cx+14, cy+20, 6, 4);
            } else {
                ctx.fillRect(cx+2, cy+20, 8, 4); ctx.fillRect(cx+14, cy+20, 8, 4);
            }
            ctx.fillStyle = this.color2;
            let ax = this.facingRight ? cx+14 : cx-2;
            ctx.fillRect(ax, cy+10, 10, 6);
        }
    }
    
    die() {
        super.die();
        setTimeout(() => gameState = 'GAME_OVER', 2000);
    }
}

class Bullet extends Entity {
    constructor(x, y, right, friendly) {
        super(x, y, 8, 6, friendly ? '#ffff00' : '#ffa500');
        this.vx = right ? BULLET_SPEED : -BULLET_SPEED;
        this.friendly = friendly;
        this.life = 90; // Increased life to ensure it goes offscreen
    }
    update() {
        this.x += this.vx;
        this.life--;
        // Kill if time out OR strictly off-camera
        if (this.life <= 0) this.dead = true;
        // Offscreen check
        if (this.x < cameraX - 50 || this.x > cameraX + VIEWPORT_WIDTH + 50) {
            this.dead = true;
        }
    }
    draw() {
        drawRect(this.x, this.y, this.w, this.h, this.color);
    }
}

class Enemy extends Entity {
    constructor(x, y, type) {
        super(x, y, 24, 24, '#00aa00');
        this.type = type;
        this.hp = 3;
        this.homeX = x;
        this.timer = 0;
        this.dir = -1;
    }
    update() {
        if (this.dead) return;
        if (Math.abs(this.x - player.x) > 600) return;

        super.update();

        if (this.type === 'met') {
             if (this.grounded) {
                 this.vx = this.dir;
                 this.timer++;
                 if (this.timer > 100) { this.dir *= -1; this.timer = 0; }
             }
        } else if (this.type === 'jumper') {
            this.timer++;
            if (this.grounded && this.timer > 100) {
                this.vy = -8;
                this.vx = (player.x < this.x) ? -2 : 2;
                this.timer = 0;
            }
            if (this.grounded) this.vx = 0;
        }

        if (this.rectIntersect(this.x, this.y, this.w, this.h, player.x, player.y, player.w, player.h)) {
            player.takeDamage(4);
        }
    }
    draw() {
        if(this.dead) return;
        let cx = Math.floor(this.x - cameraX);
        let cy = Math.floor(this.y);
        
        if (this.type === 'met') {
            ctx.fillStyle = '#FFA500';
            ctx.fillRect(cx, cy+6, 24, 12);
            ctx.fillStyle = '#000';
            ctx.fillRect(cx+4, cy+18, 16, 6);
        } else {
            ctx.fillStyle = '#00FF00';
            ctx.fillRect(cx, cy, 24, 24);
        }
    }
}

class Boss extends Entity {
    constructor(x, y) {
        super(x, y, 48, 48, '#ff0000');
        this.hp = MAX_HP;
        this.state = 'idle';
        this.timer = 0;
    }
    update() {
        if (this.dead || gameState !== 'BOSS') return;
        super.update();
        this.timer++;
        this.facingRight = player.x > this.x;

        if (this.state === 'idle') {
            this.vx = 0;
            if (this.timer > 50) {
                this.state = Math.random() < 0.5 ? 'jump' : 'shoot';
                this.timer = 0;
            }
        } else if (this.state === 'jump') {
            if (this.timer === 1) {
                this.vy = -12;
                this.vx = this.facingRight ? 5 : -5;
            }
            if (this.grounded && this.timer > 10) {
                this.state = 'idle';
                this.timer = 0;
            }
        } else if (this.state === 'shoot') {
            if ([20,40,60].includes(this.timer)) {
                let bx = this.facingRight ? this.x + 48 : this.x - 10;
                bullets.push(new Bullet(bx, this.y + 20, this.facingRight, false));
            }
            if (this.timer > 80) {
                this.state = 'idle';
                this.timer = 0;
            }
        }

        if (this.rectIntersect(this.x, this.y, this.w, this.h, player.x, player.y, player.w, player.h)) {
            player.takeDamage(6);
        }
    }
    draw() {
        if (this.dead) return;
        if (this.invincible > 0 && frameCount % 4 === 0) return;
        let cx = Math.floor(this.x - cameraX);
        let cy = Math.floor(this.y);
        ctx.fillStyle = '#b00';
        ctx.fillRect(cx, cy, 48, 48);
        ctx.fillStyle = '#f00';
        ctx.fillRect(cx+4, cy+4, 40, 20);
        ctx.fillRect(cx+4, cy+28, 12, 16);
        ctx.fillRect(cx+32, cy+28, 12, 16);
    }
    die() {
        super.die();
        setTimeout(() => gameState = 'VICTORY', 2000);
    }
}

let platforms = [];
let enemies = [];
let bullets = [];
let particles = [];
let player, boss;
let bossGate;

function initLevel() {
    platforms = [];
    enemies = [];
    bullets = [];
    particles = [];
    cameraX = 0;
    cameraLock = { min: 0, max: BOSS_GATE_TILE_X * TILE_SIZE };
    gameState = 'PLAY';
    inputEnabled = true;
    
    player = new Player(50, 200);
    boss = new Boss((BOSS_ROOM_TILE_X + 12) * TILE_SIZE, 300);
    
    bossHudEl.style.visibility = 'hidden';

    // Map
    for(let i=0; i<BOSS_ROOM_TILE_X + 16; i++) {
        if ([20,21,45,46].includes(i)) continue;
        platforms.push({x: i*TILE_SIZE, y: 416, w: TILE_SIZE, h: TILE_SIZE, active: true});
    }

    platforms.push({x: -32, y: 0, w: 32, h: 600, active: true});
    platforms.push({x: (BOSS_ROOM_TILE_X+16)*TILE_SIZE, y: 0, w: 32, h: 600, active: true});

    bossGate = {x: BOSS_GATE_TILE_X * TILE_SIZE, y: 0, w: TILE_SIZE, h: 416, active: true, type: 'gate'};
    platforms.push(bossGate);

    platforms.push({x: 10*32, y: 350, w: 96, h: 32, active:true});
    platforms.push({x: 25*32, y: 300, w: 64, h: 32, active:true});
    platforms.push({x: 35*32, y: 352, w: 96, h: 32, active:true});
    platforms.push({x: 55*32, y: 280, w: 64, h: 32, active:true});

    enemies.push(new Enemy(14*32, 380, 'met'));
    enemies.push(new Enemy(30*32, 350, 'jumper'));
    enemies.push(new Enemy(50*32, 380, 'met'));
    enemies.push(new Enemy(57*32, 250, 'met'));
}

function loop() {
    frameCount++;
    ctx.fillStyle = '#202020';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (gameState === 'START') {
        ctx.fillStyle = 'white';
        ctx.font = '30px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('ROCK BUSTER V4', VIEWPORT_WIDTH/2, 200);
        ctx.font = '12px "Press Start 2P"';
        ctx.fillText('PRESS JUMP TO START', VIEWPORT_WIDTH/2, 260);
        if (inputState.jumpPressed) {
            initLevel();
            inputState.jumpPressed = false;
        }
    }
    else {
        if (gameState === 'PLAY' && player.x > (BOSS_GATE_TILE_X * TILE_SIZE) - 64) {
            startBossSequence();
        }

        player.update();
        if (gameState === 'BOSS') boss.update();

        enemies.forEach(e => e.update());
        bullets.forEach(b => b.update());
        updateParticles();

        if (gameState === 'PLAY' || gameState === 'BOSS') {
            bullets.forEach(b => {
                if(b.dead) return;
                for(let p of platforms) {
                    if(p.active !== false && rectIntersect(b, p)) b.dead = true;
                }
                if(b.friendly) {
                    enemies.forEach(e => { if(rectIntersect(b,e)) { e.takeDamage(1); b.dead = true; }});
                    if(gameState === 'BOSS' && rectIntersect(b, boss)) { boss.takeDamage(1); b.dead = true; }
                } else {
                    if(rectIntersect(b, player)) { player.takeDamage(4); b.dead = true; }
                }
            });
        }
        
        // CRITICAL FIX: Remove dead bullets
        bullets = bullets.filter(b => !b.dead);

        let targetX = player.x - VIEWPORT_WIDTH / 2;
        if (targetX < cameraLock.min) targetX = cameraLock.min;
        if (targetX > cameraLock.max - VIEWPORT_WIDTH) targetX = cameraLock.max - VIEWPORT_WIDTH;
        
        cameraX += (targetX - cameraX) * 0.1;
        if(Math.abs(targetX - cameraX) < 1) cameraX = targetX;

        ctx.fillStyle = '#505050';
        platforms.forEach(p => {
            if(p.x - cameraX > VIEWPORT_WIDTH || p.x + p.w - cameraX < 0) return;
            
            if(p.type === 'gate') {
                if(p.active) {
                    ctx.fillStyle = '#888';
                    ctx.fillRect(Math.floor(p.x - cameraX), 0, 32, 448);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(Math.floor(p.x - cameraX + 8), 0, 16, 448);
                }
            } else {
                ctx.fillStyle = '#4040A0';
                ctx.fillRect(Math.floor(p.x - cameraX), Math.floor(p.y), p.w, p.h);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(Math.floor(p.x - cameraX), Math.floor(p.y), p.w, p.h);
            }
        });

        enemies.forEach(e => e.draw());
        if(gameState === 'BOSS') boss.draw();
        player.draw();
        bullets.forEach(b => b.draw());
        drawParticles();

        updateHpBar(playerHpEl, player.hp);
        if(gameState === 'BOSS') updateHpBar(bossHpEl, boss.hp);

        if(gameState === 'GAME_OVER') {
            ctx.fillStyle = 'red';
            ctx.textAlign = 'center';
            ctx.font = '30px "Press Start 2P"';
            ctx.fillText('GAME OVER', VIEWPORT_WIDTH/2, 224);
            ctx.fillStyle = 'white';
            ctx.font = '10px "Press Start 2P"';
            ctx.fillText('JUMP TO RETRY', VIEWPORT_WIDTH/2, 260);
            if(inputState.jumpPressed) { initLevel(); inputState.jumpPressed = false; }
        }
        if(gameState === 'VICTORY') {
            ctx.fillStyle = '#00FF00';
            ctx.textAlign = 'center';
            ctx.font = '30px "Press Start 2P"';
            ctx.fillText('MISSION CLEAR', VIEWPORT_WIDTH/2, 224);
        }
    }

    requestAnimationFrame(loop);
}

async function startBossSequence() {
    gameState = 'TRANSITION';
    inputEnabled = false;
    player.vx = 0;
    
    await wait(1000);
    bossGate.active = false;
    
    player.vx = 1.5;
    
    await waitUntil(() => player.x > (BOSS_GATE_TILE_X * TILE_SIZE) + 48);
    
    player.vx = 0;
    
    bossGate.active = true;
    
    cameraLock.min = BOSS_ROOM_TILE_X * TILE_SIZE;
    cameraLock.max = (BOSS_ROOM_TILE_X + BOSS_ROOM_WIDTH_TILES) * TILE_SIZE;
    
    gameState = 'BOSS';
    inputEnabled = true;
    bossHudEl.style.visibility = 'visible';
}

function wait(ms) { return new Promise(r => setTimeout(r, ms)); }
function waitUntil(condition) {
    return new Promise(resolve => {
        const interval = setInterval(() => {
            if(condition()) { clearInterval(interval); resolve(); }
        }, 16);
    });
}

function createExplosion(x, y) {
    for(let i=0; i<10; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6,
            life: 20, color: '#FFF'
        });
    }
}
function createDust(x, y) {
    particles.push({x:x, y:y, vx:(Math.random()-0.5), vy:-1, life:10, color:'white', isDust:true});
}
function updateParticles() {
    for(let p of particles) {
        p.x += p.vx; p.y += p.vy; p.life--;
    }
    particles = particles.filter(p => p.life > 0);
}
function drawParticles() {
    for(let p of particles) {
        ctx.fillStyle = p.color;
        let s = p.isDust ? 2 : 4;
        ctx.fillRect(Math.floor(p.x-cameraX), Math.floor(p.y), s, s);
    }
}
function drawRect(x, y, w, h, color) {
    ctx.fillStyle = color;
    ctx.fillRect(Math.floor(x - cameraX), Math.floor(y), w, h);
}
function rectIntersect(r1, r2) {
    return r2.x < r1.x + r1.w && r2.x + r2.w > r1.x && r2.y < r1.y + r1.h && r2.y + r2.h > r1.y;
}
function updateHpBar(el, hp) {
    el.innerHTML = '';
    const segments = Math.max(0, Math.ceil((hp / MAX_HP) * 28));
    for(let i=0; i<segments; i++) {
        const d = document.createElement('div');
        d.className = 'hp-segment';
        el.appendChild(d);
    }
}

initLevel();
requestAnimationFrame(loop);

</script>
</body>
</html>